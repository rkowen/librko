static const char RCSID[]="@(#)$Id: memdbg.c,v 1.1 2002/02/19 02:27:33 rk Exp $";
static const char AUTHOR[]="@(#)memdbg 1.0 2002/02/16 R.K.Owen,PhD";

/* memdbg - parses through the output generated by memdebug
 * 	analyzing the memory allocation/free calls.
 * 	Memdebug is not a replacement library for the memory
 * 	calls ... but a macro substitution for them.
 *
 *	Supports only the ANSI-C routines:
 *		  calloc,   free,   malloc,   realloc
 *	that have been substituted with the following names:
 *		m_calloc, m_free, m_malloc, m_realloc
 *	the output goes to stderr.
 */
/*
 *********************************************************************
 *
 *     This software is copyrighted by R.K.Owen,Ph.D. 2002
 *
 * The author, R.K.Owen, of this software is not liable for any
 * problems WHATSOEVER which may result from use  or  abuse  of
 * this software. The author, R.K.Owen, grants unlimited rights
 * to anyone who uses and modifies this  software  for  private
 * non-commercial  use  as  long  as  this copyright and rights
 * notice remains in this software and is made available to all
 * recipients of this software.
 *
 * last known email: librko@kooz.sj.ca.us
 *                   rk@owen.sj.ca.us
 *
 *********************************************************************
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>	/* getopt */
#include "avec.h"
#include "uvec.h"

/* global variables */
int out_mem = 0;
avec *calls;
avec *memlocs;
uvec *memlog;
char wbuf[257];

char *memcalls[] = {
	"malloc",
	"calloc",
	"realloc",
	"free",
	(char *) NULL
};

/* convert a void *  to a long */
long v2l (void *vptr) {
	unsigned int	icount;
	unsigned short	scount;
	unsigned long	lcount;

	if (sizeof(void *) == sizeof(unsigned int)) {
		icount = (unsigned int) vptr;
		lcount = icount;
	} else if (sizeof(void *) == sizeof(unsigned short)) {
		scount = (unsigned short) vptr;
		lcount = scount;
	} else if (sizeof(void *) == sizeof(unsigned long)) {
		lcount = (unsigned long) vptr;
	} else {
		lcount = (unsigned long) vptr;
	}
	return lcount;
}

int initial_memdbg (void) {
	if (avec_set_fns(AVEC_COUNT,NULL)) return -2;
	if (!(calls = avec_ctor(10))) return -1;

	if (avec_set_fns(AVEC_STDC,NULL)) return -4;
	if (!(memlocs = avec_ctor(50))) return -3;

	if (avec_resize_percentage(memlocs,40)) return -5;

	if (!(memlog = uvec_ctor(20))) return -6;

	return 0;
}

int final_memdbg (FILE *output) {
	avec_element **waeptr = (avec_element **) NULL;

	unsigned long	malloc_count = 0, calloc_count = 0,
			realloc_count = 0, free_count = 0;
	int flag = 0;
	char **mlog;

	malloc_count = v2l(avec_lookup(calls, "malloc"));
	calloc_count = v2l(avec_lookup(calls, "calloc"));
	realloc_count = v2l(avec_lookup(calls, "realloc"));
	free_count = v2l(avec_lookup(calls, "free"));

	fprintf(output, " malloc count = %ld\n",  malloc_count);
	fprintf(output, " calloc count = %ld\n",  calloc_count);
	fprintf(output, "realloc count = %ld\n", realloc_count);
	fprintf(output, "   free count = %ld\n",    free_count);
	if (malloc_count + calloc_count != free_count) {
		fprintf(output, ">>>unbalanced alloc/free count\n");
	}

	while ((waeptr = avec_walk_r(memlocs, waeptr))) {
		if (!flag) {
			fprintf(output,"\nDangling memory allocations:\n");
			flag++;
		}
		fprintf(output,"\t>>>%s:%s\n",(*waeptr)->key,
			(char *) (*waeptr)->data);
	}

	if (uvec_number(memlog)) {
		fprintf(output,"\nQuestionable memory calls:\n");
		mlog = (char **) uvec_vector(memlog);
		while (*mlog) {
			fprintf(output,"\t>>>%s\n",*mlog);
			mlog++;
		}
	}
	/* clean up memory */
	uvec_dtor(&memlog);
	avec_dtor(&memlocs);
	avec_dtor(&calls);

	return 0;
}

int process_mem(char const *mcall, char const *src, char const *mloc) {
	char *lval;
	char mbuf[512];

	lval = (char *) avec_lookup(memlocs, mloc);

	if (lval && *lval) { /* found entry */
		if (!strcmp("malloc",mcall)) {
			strcpy(mbuf,"malloc overwrite of '");
			strncat(mbuf,lval, 100);
			strcat(mbuf,"' at '");
			strncat(mbuf,src, 100);
			strcat(mbuf,"'");
			uvec_add(memlog, mbuf);
		} else if (!strcmp("free",mcall)) {
			/* this is normal */
			avec_delete(memlocs, mloc);
			avec_insert(calls,mcall);
		} else if (!strcmp("calloc",mcall)) {
			strcpy(mbuf,"calloc overwrite of '");
			strncat(mbuf,lval, 100);
			strcat(mbuf,"' at '");
			strncat(mbuf,src, 100);
			strcat(mbuf,"'");
			uvec_add(memlog, mbuf);
		} else if (!strcmp("realloc",mcall)) {
			strcpy(mbuf,"realloc overwrite of '");
			strncat(mbuf,lval, 100);
			strcat(mbuf,"' at '");
			strncat(mbuf,src, 100);
			strcat(mbuf,"'");
			uvec_add(memlog, mbuf);
		}
	} else {	/* no entry */
		if (!strcmp("malloc",mcall)) {
			/* this is normal */
			strncpy(mbuf,mcall,10);
			strcat(mbuf," ");
			strncat(mbuf,src,100);
			avec_insert(memlocs, mloc, mbuf);
			avec_insert(calls,mcall);
		} else if (!strcmp("free",mcall)) {
			strcpy(mbuf,"superfluous free at '");
			strncat(mbuf,src, 100);
			strcat(mbuf,"'");
			uvec_add(memlog, mbuf);
		} else if (!strcmp("calloc",mcall)) {
			/* this is normal */
			strncpy(mbuf,mcall,10);
			strcat(mbuf," ");
			strncat(mbuf,src,100);
			avec_insert(memlocs, mloc, mbuf);
			avec_insert(calls,mcall);
		} else if (!strcmp("realloc",mcall)) {
			/* this is normal */
			strncpy(mbuf,mcall,10);
			strcat(mbuf," ");
			strncat(mbuf,src,100);
			avec_insert(memlocs, mloc, mbuf);
			avec_insert(calls,mcall);
		}
	}
	return 0;
}

int process_line(FILE *output, char *line) {
	char *ptr;
	char mcall[10], src[128], mloc[64];

	if ((ptr = strstr(line, "RKOMEM:"))) {
		/* found a MEMDEBUG message */
		/* print everything upto the this point */
		if (ptr != line) {
			*ptr = '\0';
			fprintf(output,"%s",line);
		}
		if (out_mem) {
			fprintf(output,"R%s",ptr + 1);
		}
		ptr += 7;
		if (3 != sscanf(ptr,"%10s : %128[^:] : %64s",mcall,src,mloc))
			return -1;
		/* set last ' ' to '\0' */
		if (src[strlen(src)-1] == ' ') src[strlen(src)-1] = '\0';
		(void) process_mem(mcall, src, mloc);
	} else {
		/* just a regular line */
		fprintf(output,"%s",line);
	}
	return 0;
}

int process_input(FILE *input, FILE *output) {
	char *wptr = wbuf, *ptr;
	int wbufsize = sizeof(wbuf)/sizeof(*wbuf);
	size_t wlen = 0;
	size_t numread;

	/* make sure wbuf ends with '\0' */
	wbuf[--wbufsize] = '\0';

	/* read into buffer */
	while ((numread = fread(wptr,1,wbufsize - wlen,input) + wlen)) {
		/* set all \n to '\0' */
		ptr = wptr;			/* do only what was read */
		while (ptr - wptr < numread) {
			if (*ptr == '\n') *ptr = '\0';
			ptr++;
		}

		/* search for strings */
		ptr = wbuf;			/* look at full wbuf */
		while (ptr - wbuf < numread) {
			if (!*ptr) {	/* each '\0' is a '\n' */
				fprintf(output,"\n");
				ptr++;
			       	continue;
			}

			wlen = strlen(ptr);		/* length of line */

			if (ptr - wbuf + wlen >= wbufsize) {
			/* at end of block and possibly a split line */
				strcpy(wbuf, ptr);
				wptr = wbuf + wlen;
				ptr = wptr + numread;	/* end of block */
			} else {
				process_line(output, ptr);
				ptr += wlen;
				wlen = 0;
			}
		}
	}
	return 0;
}

void usage(char *ProgName) {

	(void) printf(
"\n"
"%s - analyzes the MEMDEBUG output checking that allocations have\n"
"	associated free's (StdC only)\n"
"\n"
"usage: %s [-h][-m][-o output][--][input ...]\n"
"	-h		this helpful information\n"
"	-m		output the MEMDEBUG lines (default = only summary)\n"
"	-o output	output file name (else defaults to stdout)\n"
"	--		stops further option processing\n"
"	input ...	one or more input file names (else defaults to stdin)\n"
"			the input of '-' will use stdin at that place\n"
"\n"
"output: the summary prints any non-match memory allocations, usually\n"
"	due to a memory leak.\n\n",
		ProgName, ProgName);
}

int main(int argc, char *argv[]) {
	int retval = 0;
	char *PrgNm = argv[0];	/* must send entire argv to getopt */
	FILE *input, *output;
	int i;

	input = stdin;
	output = stdout;

	if ((retval = initial_memdbg())) {
		fprintf(stderr,"%s : initial_memdbg failure = '%d'\n",
			PrgNm, retval);
		return retval;
	}

	while ((i = getopt(argc,argv,"hmo:")) != -1) {
		switch (i) {
		case 'h':
			usage(PrgNm);
			return 0;
			break;
		case 'm':
			out_mem = 1;
			break;
		case 'o':
			if (!(output = fopen(optarg, "w"))) {
				fprintf(stderr,"Can't open %s for writing!\n\n",
					optarg);
				usage(PrgNm);
				return 2;
			}
			break;
		case '?':
		default:
			usage(PrgNm);
			return 1;
			break;
		}
	}

	/* cycle through arguments */
	argv = &(argv[optind]);
	if (*argv) {
		while (*argv) {				/* step through args */
			if (!strcmp(*argv,"-")) {	/* want stdin */
				input = stdin;
			} else {
				if(!(input = fopen(*argv,"r"))) {
					fprintf(stderr,
					"\nCan't open %s for reading!\n\n",
						*argv);
				}
			}
			argv++;
			retval = process_input(input,output);
			fclose(input);
		}
	} else {					/* no arg hence stdin */
		retval = process_input(input,output);
	}

	if ((retval = final_memdbg(output))) {
		fprintf(stderr,"%s : final_word failure = '%d'\n",
			PrgNm, retval);
		return retval;
	}
	fclose(output);
	return 0;
}
