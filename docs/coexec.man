.\" RCSID @(#)$Id: coexec.man,v 1.1 2002/03/01 05:23:28 rk Exp $
.\" LIBDIR
.TH "COEXEC" "3rko" "28 Feb 2002"
.SH NAME
coexec \- a collection of routines communication to other executables.

.SH SYNOPSIS

.nf
#include <stdio.h>
#include "coexec.h"

FILE *preprocess(FILE *instream, char **argv, int fd);
FILE *postprocess(FILE *outstream, char **argv, int fd);

FILE *prefilter(FILE *instream, char **argv);
FILE *postfilter(FILE *outstream, char **argv);
int   closefilter(FILE *filterstream);

FILE *invoke(char **argv);
int   spawn(FILE **childin, FILE **childout, char **argv);

.fi

.SH DESCRIPTION
.I invoke
returns a file pointer to the stdout of the child process, unless
there is an error, then it returns (FILE *) NULL.
.br
.I spawn
sets up a child process and communications to the process via the
stdin and stdout FILE streams.
.br
.I argv
is a command vector, where argv[0] is the executable to run, and
argv[1],... are the commandline options.
Must have the last one argv[N] = NULL to terminate the vector.

.SH SEE ALSO
coexec(3rko),invoke(3rko),spawn(3rko),uvec(3rko),
execvp(2),fork(2),pipe(2),fclose(3),wait(2),system(3)

.SH NOTES

After the output is read and an EOF is received, the calling program should
close the file stream and wait for the child process.

 FILE *childoutput;
 ...
 childoutput = invoke(argv);
 ...
 fclose(childoutput);
 wait(NULL);

.SH DIAGNOSTICS

The errors are handled by rkoperror() (if RKOERROR is defined),
else it goes to stderr.
In either case, all child process errors go to stderr.

.SH BUGS
None discovered yet.

.SH AUTHOR
R.K.Owen,Ph.D.

.KEY WORDS
