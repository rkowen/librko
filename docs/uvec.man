.\" RCSID @(#)$Id: uvec.man,v 1.5 1999/03/25 15:08:31 rk Exp $
.\" LIBDIR
.TH "UVEC" "3rko" "31 Oct 1997"
.SH NAME
uvec \- Unix vector, a (char *)NULL terminated vector of character
strings.

.SH SYNOPSIS

.nf
#include "librko.h"
defines the following structure and enum:
typedef struct {
	char tag[5];			/* name tag for this type */
	char **vector;
	int number;			/* current number of list */
	int capacity;			/* the possible capacity of vector */
} uvec;

enum uvec_order {UVEC_ASCEND, UVEC_DESCEND
#ifndef NO_STRCASECMP
	, UVEC_CASE_ASCEND, UVEC_CASE_DESCEND
#endif
	};

uvec *uvec_ctor(int cap);
int uvec_dtor(uvec **uv);
int uvec_init(uvec *uv, int cap);
int uvec_close(uvec *uv);
int uvec_exists(uvec const *uv);
int uvec_capacity(uvec const *uv);
int uvec_number(uvec const *uv);
int uvec_end(uvec const *uv);
char ** uvec_vector(uvec const *uv);
int uvec_insert(uvec *uv, char const *str, int place);
int uvec_delete(uvec *uv, int place);
int uvec_add(uvec *uv, char const *str);
int uvec_addl(uvec *uv, ...);
int uvec_pop(uvec *uv);
int uvec_copy_vec(uvec *u, char **vec, int number);
int uvec_copy(uvec *u, uvec const *v);
int uvec_sort(uvec *uv, enum uvec_order type);
int uvec_uniq(uvec *uv, enum uvec_order type);
int uvec_reverse(uvec const *uv);
int uvec_randomize(uvec const *uv, int seed);
.fi

.SH DESCRIPTION
.I uvec
could have easily been made a C++ class, but is
confined to C so that it can be used to interact with the
exec() group of POSIX function calls for basic C programs.
Hence, for maximum object-oriented programming confine
all references to the list of functions given and pay no
attention to the members of the structure at all.
.P
A Unix vector is a list of char strings, terminated by a
(char *) NULL entry.  An example of this is char **argv
and char **environ.
.P
All the functions,
except for the accessor and constructor functions,
return 0 if no error or return <0 otherwise.

.TP 15
.I uvec_ctor
construct Unix vector to capacity ``cap''.

.TP
.I uvec_dtor
destroy the Unix vector.

.TP
.I uvec_init
initialize Unix vector to capacity ``cap''.

.TP
.I uvec_close
destroy the Unix vector contents.
.TP
.I uvec_exists
returns 0 if the vector is not constructed.
.TP
.I uvec_capacity
returns the maximum capacity of the vector, otherwise returns -1
if the vector is not defined or there are no elements.
.TP
.I uvec_number
returns the current number of entries (must always be less than
the capacity, otherwise returns -1 if the vector is not defined.
.TP
.I uvec_end
returns (number - 1), this is the last element in the vector,
otherwise returns -1 if the vector is not defined.
.TP
.I uvec_vector
returns the
.I char **
vector, otherwise returns
.I (char **) NULL
if the vector is not defined.
.TP
.I uvec_insert
insert an element before element ``place''.
.TP
.I uvec_delete
delete an element at element ``place''.
.TP
.I uvec_add
add one element to end of vector.
.TP
.I uvec_addl
add a NULL terminated list of elements to end of vector.
.TP
.I uvec_pop
pop off one element at end of vector.
.TP
.I uvec_copy_vec
copy an existing char vector to an unitialized uvec.
.TP
.I uvec_copy
copy one uvec to another unitialized one.
.TP
.I uvec_sort
sort the vector, given the following types:
UVEC_ASCEND, UVEC_DESCEND, UVEC_CASE_ASCEND, UVEC_CASE_DESCEND,
where the last two are only available if the
.I strcasecmp
function is available for ``caseless'' string comparisons.
.TP
.I uvec_uniq
remove all adjacent duplicate elements, where
type = uvec sorting type ... the important information is whether
to use a caseless comparison or not.
.TP
.I uvec_reverse
reverses the element order of the vector.
.TP
.I uvec_randomize
randomizes the vector, will be repeatable if
given the same random number seed.
If seed <=0 then will "randomly" choose one.

.SH EXAMPLES

.nf
#define RKOERROR
#include <stdio.h>
#include "librko.h"

int main() {
	uvec *u;
	int estat=0;
	char buffer[128];
	char **vec;
	int i;

	if(!(u = uvec_ctor(10))) rkoperror("main");

	for (i = 0; i < 12; ++i) {
		(void) sprintf(buffer, ":%0.2d:", i);
		if (uvec_add(u, buffer)) rkoperror("main");
	}
	/* can access the elements ``directly'' */
	*(uvec_vector(u)[0]) = 'x';
	*(uvec_vector(u)[5]) = 'x';

	if(uvec_pop(u)) rkoperror("main");
	if(uvec_pop(u)) rkoperror("main");

	vec = uvec_vector(u);
	if (uvec_exists(u)) {
		for (i = 0; *vec != (char *) NULL; ++i, ++vec) {
			printf("\t-%s-", *vec);
			if (!((i+1)%5)) printf("\n");
		}
		printf("\n");
		printf("\tend = %d, number = %d, capacity = %d\n",
			uvec_end(u), uvec_number(u), uvec_capacity(u));
	}

	if(uvec_dtor(&u)) rkoperror("main");

	return 0;
}
.fi
.P
Should get the following results:
.nf
        -x00:-  -:01:-  -:02:-  -:03:-  -:04:-
        -x05:-  -:06:-  -:07:-  -:08:-  -:09:-

        end = 9, number = 10, capacity = 15
.fi

.SH SEE ALSO
environ(5),exec(2),strcasecmp(3),rkoerror(3rko),urand(3rko)

.SH NOTES

.SH DIAGNOSTICS
Uses the
.I rkoerror
mechanism, and should be self explanatory.

.SH BUGS
Only deletes one element at a time, because I found no
real need to do otherwise.  However, the sources are general enough
that it could easily handle this event.

.SH AUTHOR
R.K.Owen,Ph.D. 10/31/1997

.KEY WORDS
